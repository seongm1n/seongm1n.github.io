---
title: "Codeforces #941 (div.2) í›„ê¸°"
date: 2024-04-28 00:00:00 +0800
categories: [codeforces, "div2"]
tags: ["#941", codeforces, "div2"]
math: true
render_with_liquid: false
---
### ì½”ë“œí¬ìŠ¤ ì²«ë²ˆì§¸ íšŒê³ 
ì½”ë“œí¬ìŠ¤ë¥¼ ì‹œì‘í•œì§€ëŠ” ì–¼ë§ˆë˜ì§€ ì•Šì•˜ë‹¤. contest ê¸°ì¤€ìœ¼ë¡œ 3ë²ˆì •ë„ ì°¸ê°€í•´ë´¤ë˜ ê²ƒ ê°™ë‹¤.<br> ì•„ë¬´ë˜ë„ ì˜ì–´ì— ëŠ¥ìˆ™í•˜ì§€ ì•Šì€ ì ì´ ì œì¼ ì–´ë µë‹¤. ëª¨ë¥´ëŠ” í‘œí˜„ë“¤ì´ ë§ì´ ë‚˜ì™€ì„œ ì•„ì§ê¹Œì§„ ë³€ì—­ê¸°ì— ë„ì›€ì„ ë§ì´ ë°›ê³  ìˆë‹¤. ê·¸ë¦¬ê³  div2 ê¸°ì¤€ìœ¼ë¡œ a, b ë§ìœ¼ë©´ c, dê¹Œì§€ê°€ ê·¸ë¦¬ë”” ë¬¸ì œì´ë‹¤. ê°œì¸ì ìœ¼ë¡œ ê·¸ë¦¬ë””ê°€ ì•½í•˜ë‹¤ê³  ìƒê°í•˜ê¸°ì— ê·¸ë¦¬ë””ë¥¼ ì—°ìŠµí•˜ëŠ”ë°ëŠ” ì¢‹ì§€ë§Œ ì•„ë¬´ë˜ë„ ì´ˆë°˜ì— ì˜ ìŠ¤í¼íŠ¸ê°€ ë‚˜ì§€ ì•ŠëŠ”ë‹¤.

ê¸°ì¡´ì—ëŠ” ë°±ì¤€ì„ ê°€ì¥ ë§ì´ í’€ì—ˆì—ˆë‹¤. ì•„ë¬´ë˜ë„ ìˆ˜ì¤€ë³„ë¡œ ì˜ ë‚˜ëˆ ì ¸ ìˆëŠ” ë ˆì´íŒ… ì‹œìŠ¤í…œê³¼ ë‹¤ë¥¸ ì‚¬ëŒê³¼ ì§ì ‘ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆëŠ” ê²½ìŸ ì‹œìŠ¤í…œì´ ë§¤ë ¥ì ì´ì—ˆë‹¤. í•˜ì§€ë§Œ êµ­ë‚´ì—ì„œ ìœ ëª…í•œ ë§Œí¼ ë‹¤ë¥¸ ì‚¬ëŒì˜ ì½”ë“œë¥¼ ì°¸ê³ í•˜ê¸°ë„ ë„ˆë¬´ ì‰½ê³  ë¬¸ì œìˆ˜ë¡œ ë­í‚¹ì„ ë‚˜ëˆ„ëŠ”ê²ƒë„ ì‹¤ë ¥ìˆœì€ ì•„ë‹ˆë¼ê³  ìƒê°í–ˆë‹¤.

ê·¸ì— ë¹„í•´ ì½”ë“œí¬ìŠ¤ëŠ” ìƒë‹¹íˆ ë§¤ë ¥ì ì´ë‹¤. ì£¼1íšŒì´ìƒ ëŒ€íšŒê°€ ì—´ë¦¬ê³  ëŒ€íšŒ ê²°ê³¼ë¡œ ë ˆì´íŒ…ì´ ì •í•´ì§„ë‹¤. ë‹¹ì—°íˆ ë‹¤ë¥¸ì‚¬ëŒì˜ ì½”ë“œ ì°¸ê³ ë„ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ê·¸ë¦¬ê³  ëŒ€íšŒê°€ ëë‚˜ë©´ í‹€ë¦° ë¬¸ì œì˜ ë°˜ë¡€ë„ í™•ì¸ì´ ê°€ëŠ¥í•˜ê³  í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë„ ë¹„êµì  ë‹¤ì–‘í•´ì„œ ì—…ì†”ë¹™ì´ í¸ë¦¬í•˜ë‹¤.

ë‹¤ë§Œ ì•„ì§ ì˜ì–´ê°€ ë¯¸ìˆ™í•˜ê³ , ë¬¸ì œì—ë„ ì ì‘í•˜ê³  ìˆëŠ” ë‹¨ê³„ë¼ì„œ ë…¸ë ¥ì´ ë§ì´ í•„ìš”í•´ ë³´ì¸ë‹¤. ~~ps ê´´ë¬¼ì´ ë„ˆë¬´ ë§ë‹¤~~ ê¾¸ì¤€ì´ contest ë§Œì´ë¼ë„ ì°¸ê°€í•´ì„œ ì‹¤ë ¥ì„ ëŒì–´ ì˜¬ë ¤ë³´ê³  ì‹¶ë‹¤.

## ë¬¸ì œ. A
ë¬¸ì œ ì¶œì²˜ : [https://codeforces.com/contest/1966/problem/A](https://codeforces.com/contest/1966/problem/A)
<center>

<b>A. Card Exchange</b><br>
time limit per test1 second<br>
memory limit per test256 megabytes<br>
input<br>standard input<br>
output<br>standard output
</center><br>

You have a hand of ğ‘› cards, where each card has a number written on it, and a fixed integer ğ‘˜. You can perform the following operation any number of times:

Choose any ğ‘˜ cards from your hand that all have the same number. Exchange these cards for ğ‘˜âˆ’1 cards, each of which can have any number you choose (including the number written on the cards you just exchanged).
Here is one possible sequence of operations for the first example case, which has ğ‘˜=3:

![A941](/assets/img/A941.png)

What is the minimum number of cards you can have in your hand at the end of this process?

Input<br>
The first line of the input contains a single integer ğ‘¡
 (1â‰¤ğ‘¡â‰¤500
) â€” the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers ğ‘› and ğ‘˜ (1â‰¤ğ‘›â‰¤100, 2â‰¤ğ‘˜â‰¤100) â€” the number of cards you have, and the number of cards you exchange during each operation, respectively.

The next line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤100) â€” the numbers written on your cards.

Output<br>
For each test case, output a single integer â€” the minimum number of cards you can have left in your hand after any number of operations.
<br>

### ì ‘ê·¼
ì½”ë“œí¬ìŠ¤ A ë¬¸ì œëŠ” ê±°ì˜ ê·¸ë¦¬ë”” ë¬¸ì œê°€ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ë‹¤. ë‹¹ì—°íˆ ê·¸ë¦¬ë””ë¶€í„° ìƒê°í–ˆë‹¤.<br>
ì¡°ê¸ˆë§Œ ìƒê°í•´ë³´ë©´ ê°™ì€ ìˆ«ìê°€ kê°œ ì´ìƒ ìˆëŠ” ì¹´ë“œë¼ í•œ ê·¸ë£¹ì´ë¼ë„ ìˆìœ¼ë©´ ì›í•˜ëŠ” ì¹´ë“œë¥¼ k-1ì¥ ì–»ì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì–´ë–¤ ì¹´ë“œëŠ” ì†Œê±°ê°€ ê°€ëŠ¥í•˜ë‹¤.<br>

### í’€ì´
ê° ìˆ«ì ì¹´ë“œê°€ ëª‡ê°œì”© ìˆëŠ”ì§€ í™•ì¸í•˜ê³  kê°œê°€ ìˆëŠ” ìˆ«ìê°€ 1ê·¸ë£¹ì´ë¼ë„ ìˆìœ¼ë©´ ë‹µì€ k-1 ì—†ë‹¤ë©´ ë‹µì€ n ì´ë‹¤.

### ì½”ë“œ

```python
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    bit = [0] * 101
    for card in cards:
        bit[card] += 1
    if max(bit) >= k:
        print(k - 1)
    else:
        print(n)
```

### í›„ê¸°
div2 ê¸°ì¤€ Aë¬¸ì œëŠ” í‰ê·  10ë¶„ì—ì„œ 20ë¶„ ì •ë„ ê±¸ë¦¬ëŠ” ê²ƒ ê°™ë‹¤. ì˜ì–´ë¼ì„œ ë‚´ê°€ ì´í•´ í•˜ëŠ”ë° ì‹œê°„ì´ ê±¸ë¦¬ëŠ”ê±´ì§€ ì½”ë“œí¬ìŠ¤ì—ì„œ ë¬¸ì œë¥¼ ì´í•´í•˜ê¸° ì–´ë µê²Œ ë‚´ëŠ”ê±´ì§€ëŠ” ì˜ ëª¨ë¥´ê² ë‹¤.

## ë¬¸ì œ. B

ë¬¸ì œ ì¶œì²˜ : [https://codeforces.com/contest/1966/problem/B](https://codeforces.com/contest/1966/problem/B)

<center>
<b>B. Rectangle Filling </b><br>
time limit per test1 second <br>
memory limit per test256 megabytes <br>
input<br> standard input <br>
output<br>standard output <br>
</center>

There is an ğ‘›Ã—ğ‘š
 grid of white and black squares. In one operation, you can select any two squares of the same color, and color all squares in the subrectangle between them that color.

Formally, if you select positions (ğ‘¥1,ğ‘¦1)
 and (ğ‘¥2,ğ‘¦2)
, both of which are currently the same color ğ‘
, set the color of all (ğ‘¥,ğ‘¦)
 where min(ğ‘¥1,ğ‘¥2)â‰¤ğ‘¥â‰¤max(ğ‘¥1,ğ‘¥2)
 and min(ğ‘¦1,ğ‘¦2)â‰¤ğ‘¦â‰¤max(ğ‘¦1,ğ‘¦2)
 to ğ‘
.

This diagram shows a sequence of two possible operations on a grid:

![B941](/assets/img/B941.png)

Is it possible for all squares in the grid to be the same color, after performing any number of operations (possibly zero)?

Input

The first line of the input contains a single integer ğ‘¡
 (1â‰¤ğ‘¡â‰¤104
) â€” the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers ğ‘›
 and ğ‘š
 (1â‰¤ğ‘›,ğ‘šâ‰¤500
) â€” the number of rows and columns in the grid, respectively.

Each of the next ğ‘›
 lines contains ğ‘š
 characters 'W' and 'B' â€” the initial colors of the squares of the grid.

It is guaranteed that the sum of ğ‘›â‹…ğ‘š
 over all test cases does not exceed 3â‹…105
.

Output

For each test case, print "YES" if it is possible to make all squares in the grid the same color, and "NO" otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

### ì ‘ê·¼
ì£¼ì–´ì§„ ì‚¬ê°í˜•ì˜ ë§¨ìœ„, ë§¨ì•„ë˜, ë§¨ì˜¤ë¥¸ìª½, ë§¨ì™¼ìª½ì— wê°€ í•œê°œ ì´ìƒì”© ìˆìœ¼ë©´ ì „ë¶€ wë¡œ ì¹ í•  ìˆ˜ ìˆë‹¤. bë„ ë§ˆì°¬ê°€ì§€

### í’€ì´
w ë˜ëŠ” bê°€ í•œê°œì”© ìˆëŠ”ì§€ í™•ì¸í•œ í›„ w, b ë‘˜ì¤‘ì— í•œê°œë¼ë„ ì¹ í•  ìˆ˜ ìˆë‹¤ë©´ true

```python
t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    graph = []
    for i in range(n):
        graph.append(input())
    black = True
    white = True
 
    b, w = False, False
    for i in range(n):
        if graph[i][0] == 'B':
            b = True
        else:
            w = True
    black, white = b and black, w and white
 
    b, w = False, False
    for i in range(n):
        if graph[i][-1] == 'B':
            b = True
        else:
            w = True
    black, white = b and black, w and white
 
    b, w = False, False
    for i in range(m):
        if graph[0][i] == 'B':
            b = True
        else:
            w = True
    black, white = b and black, w and white
 
    b, w = False, False
    for i in range(m):
        if graph[-1][i] == 'B':
            b = True
        else:
            w = True
    black, white = b and black, w and white
 
    if black or white:
        print("YES")
    else:
        print("NO")
```

### í›„ê¸°
Bë¬¸ì œê¹Œì§€ëŠ” í•­ìƒ ë¬´ë‚œí•˜ê²Œ í’€ë¦°ë‹¤. íŠ¹íˆ ì´ë²ˆì—ëŠ” ì˜ˆì‹œê°€ ì§ê´€ì ì´ë¼ì„œ Aë¬¸ì œë³´ë‹¤ ë” ë¹ ë¥´ê²Œ í’€ì—ˆë˜ ê²ƒ ê°™ë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ ê·¸ë¦¬ë””